%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{wfomi}
\date{May 26, 2020}
\release{0.1}
\author{korecki}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{parser}
\label{\detokenize{index:module-parser}}\label{\detokenize{index:parser}}\index{module@\spxentry{module}!parser@\spxentry{parser}}\index{parser@\spxentry{parser}!module@\spxentry{module}}\phantomsection\label{\detokenize{index:module-0}}\index{module@\spxentry{module}!parser@\spxentry{parser}}\index{parser@\spxentry{parser}!module@\spxentry{module}}\index{Parser (class in parser)@\spxentry{Parser}\spxextra{class in parser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{parser.}}\sphinxbfcode{\sphinxupquote{Parser}}}
the parser for the default circuit and weight files defined by the author. The files descriptions can be found in the docs
\index{adjustConstNodes() (parser.Parser method)@\spxentry{adjustConstNodes()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.adjustConstNodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{adjustConstNodes}}}{\emph{\DUrole{n}{constCorrection}}}{}
adjusts the circuit by moving the constant nodes down when they are above a univesal quantifier over the same domain

\end{fulllineitems}

\index{ancestorIsForAll() (parser.Parser method)@\spxentry{ancestorIsForAll()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.ancestorIsForAll}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ancestorIsForAll}}}{\emph{\DUrole{n}{node}}}{}
a helper function used in adjustConstNodes to check if the node has a universal quantifier as an ancestor

\end{fulllineitems}

\index{connectNodes() (parser.Parser method)@\spxentry{connectNodes()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.connectNodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{connectNodes}}}{}{}
connects the nodes in self.nodes dictionary based on data in self.connections

\end{fulllineitems}

\index{nextMatchingForAll() (parser.Parser method)@\spxentry{nextMatchingForAll()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.nextMatchingForAll}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nextMatchingForAll}}}{\emph{\DUrole{n}{node}}, \emph{\DUrole{n}{domain}}}{}
a helper function used in adjustConstNodes to detect the next universal quantifier of a given node with matching domain

\end{fulllineitems}

\index{parseCircuit() (parser.Parser method)@\spxentry{parseCircuit()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.parseCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parseCircuit}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{weights}}, \emph{\DUrole{n}{domains}}}{}
parses a circuit file with the given name and creates nodes using data on the weight functions and domains

\end{fulllineitems}

\index{parseConnections() (parser.Parser method)@\spxentry{parseConnections()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.parseConnections}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parseConnections}}}{\emph{\DUrole{n}{content}}}{}
parses the link lines of a circuit file with the given name and stores the connections between nodes in self.connections, 
and self.reverseConnections

\end{fulllineitems}

\index{parseConst() (parser.Parser method)@\spxentry{parseConst()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.parseConst}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parseConst}}}{\emph{\DUrole{n}{line}}, \emph{\DUrole{n}{domains}}, \emph{\DUrole{n}{weights}}, \emph{\DUrole{n}{constCorrection}}, \emph{\DUrole{n}{node}}}{}
parses a line contianing a constant node

\end{fulllineitems}

\index{parseNodes() (parser.Parser method)@\spxentry{parseNodes()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.parseNodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parseNodes}}}{\emph{\DUrole{n}{content}}, \emph{\DUrole{n}{constCorrection}}, \emph{\DUrole{n}{weights}}, \emph{\DUrole{n}{domains}}}{}
parses the node lines of a circuit file with the given name, creates and stores the nodes in the nodes dictionary

\end{fulllineitems}

\index{parseQuantifier() (parser.Parser method)@\spxentry{parseQuantifier()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.parseQuantifier}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parseQuantifier}}}{\emph{\DUrole{n}{line}}, \emph{\DUrole{n}{domains}}}{}
parses a line contianing a universal or existential quantifier

\end{fulllineitems}

\index{parseWeights() (parser.Parser method)@\spxentry{parseWeights()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.parseWeights}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parseWeights}}}{\emph{\DUrole{n}{name}}}{}
parses the weight file

\end{fulllineitems}


\end{fulllineitems}



\chapter{term}
\label{\detokenize{index:module-term}}\label{\detokenize{index:term}}\index{module@\spxentry{module}!term@\spxentry{term}}\index{term@\spxentry{term}!module@\spxentry{module}}\phantomsection\label{\detokenize{index:module-1}}\index{module@\spxentry{module}!term@\spxentry{term}}\index{term@\spxentry{term}!module@\spxentry{module}}\index{Term (class in term)@\spxentry{Term}\spxextra{class in term}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:term.Term}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{term.}}\sphinxbfcode{\sphinxupquote{Term}}}{\emph{\DUrole{n}{weights}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{bounds}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{const}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
The Term object represent the smallest computational unit over the circuit representation. The Term is used to store the weight
functions in symbolic form, the associated bounds and the constant multiplier. The term implements multiplication and addition as well
as integration. The weights, bounds and constants are all lists and their elements corresponding to elements of a sum.
\index{integrate() (term.Term method)@\spxentry{integrate()}\spxextra{term.Term method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:term.Term.integrate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate}}}{}{}
Implements efficient integation of a term.

\end{fulllineitems}


\end{fulllineitems}

\index{integrateFromDict() (in module term)@\spxentry{integrateFromDict()}\spxextra{in module term}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:term.integrateFromDict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{term.}}\sphinxbfcode{\sphinxupquote{integrateFromDict}}}{\emph{\DUrole{n}{wf}}, \emph{\DUrole{n}{bounds}}}{}
helper function for the integration

\end{fulllineitems}

\index{symbolicToNumeric() (in module term)@\spxentry{symbolicToNumeric()}\spxextra{in module term}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:term.symbolicToNumeric}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{term.}}\sphinxbfcode{\sphinxupquote{symbolicToNumeric}}}{\emph{\DUrole{n}{wf}}, \emph{\DUrole{n}{bounds}}}{}
helper function for the integration

\end{fulllineitems}



\chapter{circuit}
\label{\detokenize{index:module-circuit}}\label{\detokenize{index:circuit}}\index{module@\spxentry{module}!circuit@\spxentry{circuit}}\index{circuit@\spxentry{circuit}!module@\spxentry{module}}\phantomsection\label{\detokenize{index:module-2}}\index{module@\spxentry{module}!circuit@\spxentry{circuit}}\index{circuit@\spxentry{circuit}!module@\spxentry{module}}
each node has a compute class which follows the computation step of the algorithm for the given node
the maxDomainSize is used to compute the maximum domain size for the existential node
.. moduleauthor:: Marcin Korecki
\index{AndNode (class in circuit)@\spxentry{AndNode}\spxextra{class in circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.AndNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{circuit.}}\sphinxbfcode{\sphinxupquote{AndNode}}}{\emph{\DUrole{n}{left}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{right}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\index{compute() (circuit.AndNode method)@\spxentry{compute()}\spxextra{circuit.AndNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.AndNode.compute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute}}}{\emph{\DUrole{n}{domSize}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{removed}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
computes the symbolic value at the and node by multiplying two terms at its child nodes. the domSize and removed are passed for 
potential existential and universals that may be the node’s descendants

\end{fulllineitems}

\index{maxDomainSize() (circuit.AndNode method)@\spxentry{maxDomainSize()}\spxextra{circuit.AndNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.AndNode.maxDomainSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{maxDomainSize}}}{}{}
used to compute the maximum domain size for the existential node

\end{fulllineitems}


\end{fulllineitems}

\index{ConstNode (class in circuit)@\spxentry{ConstNode}\spxextra{class in circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ConstNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{circuit.}}\sphinxbfcode{\sphinxupquote{ConstNode}}}{\emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{nodeName}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{varList}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{domData}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\index{compute() (circuit.ConstNode method)@\spxentry{compute()}\spxextra{circuit.ConstNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ConstNode.compute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute}}}{\emph{\DUrole{n}{domSize}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{removed}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Computes the symbolic value at the constant node depending on its type

\end{fulllineitems}

\index{maxDomainSize() (circuit.ConstNode method)@\spxentry{maxDomainSize()}\spxextra{circuit.ConstNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ConstNode.maxDomainSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{maxDomainSize}}}{}{}
used to compute the maximum domain size for the existential node

\end{fulllineitems}


\end{fulllineitems}

\index{ExistsNode (class in circuit)@\spxentry{ExistsNode}\spxextra{class in circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ExistsNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{circuit.}}\sphinxbfcode{\sphinxupquote{ExistsNode}}}{\emph{\DUrole{n}{var}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{domData}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\index{compute() (circuit.ExistsNode method)@\spxentry{compute()}\spxextra{circuit.ExistsNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ExistsNode.compute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute}}}{\emph{\DUrole{n}{domSize}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{removed}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
computes the symbolic value at the existential node based on the size of the domain it quantifies over and taking into account the
objects removed from it

\end{fulllineitems}

\index{maxDomainSize() (circuit.ExistsNode method)@\spxentry{maxDomainSize()}\spxextra{circuit.ExistsNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ExistsNode.maxDomainSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{maxDomainSize}}}{}{}
used to compute the maximum domain size for the existential node

\end{fulllineitems}


\end{fulllineitems}

\index{ForAllNode (class in circuit)@\spxentry{ForAllNode}\spxextra{class in circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ForAllNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{circuit.}}\sphinxbfcode{\sphinxupquote{ForAllNode}}}{\emph{\DUrole{n}{var}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{domData}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\index{compute() (circuit.ForAllNode method)@\spxentry{compute()}\spxextra{circuit.ForAllNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ForAllNode.compute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute}}}{\emph{\DUrole{n}{domSize}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{removed}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
computes the numerical value at the universal node based on the size of the domain it quantifies over taking into account the 
objects that have been removed from it

\end{fulllineitems}

\index{maxDomainSize() (circuit.ForAllNode method)@\spxentry{maxDomainSize()}\spxextra{circuit.ForAllNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ForAllNode.maxDomainSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{maxDomainSize}}}{}{}
used to compute the maximum domain size for the existential node

\end{fulllineitems}


\end{fulllineitems}

\index{LeafNode (class in circuit)@\spxentry{LeafNode}\spxextra{class in circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.LeafNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{circuit.}}\sphinxbfcode{\sphinxupquote{LeafNode}}}{\emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{weights}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\index{compute() (circuit.LeafNode method)@\spxentry{compute()}\spxextra{circuit.LeafNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.LeafNode.compute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute}}}{\emph{\DUrole{n}{domSize}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{removed}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
computes the symbolic value at the leaves depending on weather the corresponding weight is a float or a function

\end{fulllineitems}

\index{maxDomainSize() (circuit.LeafNode method)@\spxentry{maxDomainSize()}\spxextra{circuit.LeafNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.LeafNode.maxDomainSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{maxDomainSize}}}{}{}
used to compute the maximum domain size for the existential node

\end{fulllineitems}


\end{fulllineitems}

\index{Node (class in circuit)@\spxentry{Node}\spxextra{class in circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.Node}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{circuit.}}\sphinxbfcode{\sphinxupquote{Node}}}{\emph{\DUrole{n}{left}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{right}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
The base class defining a node, all other nodes inherit from it
\index{maxDomainSize() (circuit.Node method)@\spxentry{maxDomainSize()}\spxextra{circuit.Node method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.Node.maxDomainSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{maxDomainSize}}}{}{}
used to compute the maximum domain size for the existential node

\end{fulllineitems}


\end{fulllineitems}

\index{OrNode (class in circuit)@\spxentry{OrNode}\spxextra{class in circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.OrNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{circuit.}}\sphinxbfcode{\sphinxupquote{OrNode}}}{\emph{\DUrole{n}{left}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{right}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\index{compute() (circuit.OrNode method)@\spxentry{compute()}\spxextra{circuit.OrNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.OrNode.compute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute}}}{\emph{\DUrole{n}{domSize}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{removed}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
computes the symbolic value at the or node by adding two terms at its child nodes, the setsize and removed are passed for potential 
existential and universals that may be the node’s descendants

\end{fulllineitems}

\index{maxDomainSize() (circuit.OrNode method)@\spxentry{maxDomainSize()}\spxextra{circuit.OrNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.OrNode.maxDomainSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{maxDomainSize}}}{}{}
used to compute the maximum domain size for the existential node

\end{fulllineitems}


\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{c}
\item\relax\sphinxstyleindexentry{circuit}\sphinxstyleindexpageref{index:\detokenize{module-2}}
\indexspace
\bigletter{p}
\item\relax\sphinxstyleindexentry{parser}\sphinxstyleindexpageref{index:\detokenize{module-0}}
\indexspace
\bigletter{t}
\item\relax\sphinxstyleindexentry{term}\sphinxstyleindexpageref{index:\detokenize{module-1}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}